{"meta":{"title":"stpehac的博客","subtitle":null,"description":null,"author":"stpehen","url":"http://imwyy.github.io"},"pages":[{"title":"categories","date":"2017-12-11T07:01:16.000Z","updated":"2017-12-11T07:01:44.353Z","comments":true,"path":"categories/index.html","permalink":"http://imwyy.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-12-11T07:01:23.000Z","updated":"2017-12-11T07:02:18.655Z","comments":true,"path":"about/index.html","permalink":"http://imwyy.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-11T06:44:04.000Z","updated":"2017-12-11T07:02:27.209Z","comments":true,"path":"tags/index.html","permalink":"http://imwyy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"干货集","slug":"干货","date":"2017-12-11T06:39:36.000Z","updated":"2017-12-11T07:57:31.092Z","comments":true,"path":"2017/12/11/干货/","link":"","permalink":"http://imwyy.github.io/2017/12/11/干货/","excerpt":"","text":"HTTP报文GET和POST请求的区别HTTP2.0","categories":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/categories/干货/"}],"tags":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/tags/干货/"}]},{"title":"rxjava2的disposable","slug":"rxjava2的disposable","date":"2017-12-10T14:54:06.000Z","updated":"2017-12-11T08:55:37.775Z","comments":true,"path":"2017/12/10/rxjava2的disposable/","link":"","permalink":"http://imwyy.github.io/2017/12/10/rxjava2的disposable/","excerpt":"","text":"rxjava+retrofit处理网络请求在使用rxjava+retrofit处理网络请求的时候，一般会采用对观察者进行封装，实现代码复用和拓展。一种可行的封装如下： 基类observer 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class BaseObserver&lt;T&gt; implements Observer&lt;T&gt; &#123; protected String errMsg = \"\"; protected Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; disposable = d; &#125; @Override public void onNext(T t) &#123; &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(\"Subscriber onError\", e.getMessage()); if (!NetworkUtils.isConnected()) &#123; errMsg = \"网络连接出错,\"; &#125; else if (e instanceof APIException) &#123; APIException exception = (APIException) e; errMsg = exception.getMessage() + \", \"; &#125; else if (e instanceof HttpException) &#123; errMsg = \"网络请求出错,\"; &#125; else if (e instanceof IOException) &#123; errMsg = \"网络出错,\"; &#125; if (disposable != null &amp;&amp; !disposable.isDisposed()) &#123; disposable.dispose(); &#125; &#125; @Override public void onComplete() &#123; if (disposable != null &amp;&amp; !disposable.isDisposed()) &#123; disposable.dispose(); &#125; &#125;&#125; 封装请求（登录为例） 这里userService是retrofit接口类 123456789101112 /** * 登录 * @param phone 账号 * @param password 密码 * @param observer 观察者 */ public void login(String phone, String password, BaseObserver&lt;ResponseBean&lt;UidBean&gt;&gt; observer) &#123;// userService.login(new RequestUserBean(phone, EncryptUtils.encryptMD5ToString(password))) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 方法调用 1234567891011121314151617APIUser.getInstance().login(phone, password, new BaseObserver&lt;ResponseBean&lt;UidBean&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; addDisposable(d); &#125; @Override public void onNext(ResponseBean&lt;UidBean&gt; responseBean) &#123; ToastUtils.showShort(\"登录成功\"); &#125; @Override public void onError(Throwable e) &#123; super.onError(e); ToastUtils.showShort(errMsg+\"登录失败\"); &#125; &#125;); 网上大家对rxjava+retrofit好的封装很多，我这里不再赘述。 关于disposablerxjava虽然好用，但是总所周知，容易遭层内存泄漏。也就说在订阅了事件后没有及时取阅，导致在activity或者fragment销毁后仍然占用着内存，无法释放。而disposable便是这个订阅事件，可以用来取消订阅。但是在什么时候取消订阅呢？我知道有两种方式: 使用CompositeDisposable 看源码，CompositeDisposable的介绍很简单 A disposable container that can hold onto multiple other disposables and offers O(1) add and removal complexity. 一个disposable的容器，可以容纳多个disposable，添加和去除的复杂度为O(1)。这里需要注意的是在该类的addAll方法有这么一句注释 Atomically adds the given array of Disposables to the container or disposes them all if the container has been disposed 也就是说，如果这个CompositeDisposable容器已经是处于dispose的状态，那么所有加进来的disposable都会被自动切断。 所以说可以创建一个BaseActivity，用CompositeDisposable来管理订阅事件disposable，然后在acivity销毁的时候，调用compositeDisposable.dispose()就可以切断所有订阅事件，防止内存泄漏。 在oError和onComplete后调用disposable.dispose();，也就是上面我给的例子中的方法。 查看源码，ObservableCreate的静态类CreateEmitter就是这种方式实现的。同时也可以看到，onError和onComplete不可以同时调用的原因：每次掉用过onError或onComplete其中一个方法后，就会掉用dispose()方法，此时订阅取消，自然也就不能掉用另一个方法了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = -3434801548987643227L; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; @Override public void onError(Throwable t) &#123; if (t == null) &#123; t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); &#125; if (!isDisposed()) &#123; try &#123; observer.onError(t); &#125; finally &#123; dispose(); &#125; &#125; else &#123; RxJavaPlugins.onError(t); &#125; &#125; @Override public void onComplete() &#123; if (!isDisposed()) &#123; try &#123; observer.onComplete(); &#125; finally &#123; dispose(); &#125; &#125; &#125; @Override public void setDisposable(Disposable d) &#123; DisposableHelper.set(this, d); &#125; @Override public void setCancellable(Cancellable c) &#123; setDisposable(new CancellableDisposable(c)); &#125; @Override public ObservableEmitter&lt;T&gt; serialize() &#123; return new SerializedEmitter&lt;T&gt;(this); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125; &#125; 除此之外，在github发现一个开源库RxLifecyclee，粗略了解发现他实现的原理是绑定acvitvity是生命周期，在onStart中绑定就在onStop中解绑，其他onResume，onCreate同理。这个和第一种方式似乎又差不多，只不过第一种方式简单，只在ondestory的时候销毁所有事件。 所以那两种方法哪种更好，我也不是很清楚。等到踩到什么坑了可能就知道了。如果某位大佬知道，希望不吝指教。","categories":[{"name":"andorid开发","slug":"andorid开发","permalink":"http://imwyy.github.io/categories/andorid开发/"}],"tags":[{"name":"andorid","slug":"andorid","permalink":"http://imwyy.github.io/tags/andorid/"}]},{"title":"安装配置mongoDB","slug":"安装配置mongoDB","date":"2017-12-09T12:27:36.000Z","updated":"2017-12-10T11:16:42.465Z","comments":true,"path":"2017/12/09/安装配置mongoDB/","link":"","permalink":"http://imwyy.github.io/2017/12/09/安装配置mongoDB/","excerpt":"","text":"最近在在学习nodejs，相比mysql，mongodb与nodejs搭配更合适，存储数据格式也比较接近JS对象。关于mysql和mongodb两种类型数据库的差别与对比，下篇文章再写。下面来看一下如何在mac上安装mongodb。 Homebrew你可以选择选择下载mongodb源码编译安装，当然在mac上更方便快捷的方式是用homebrew安装。homebrew是mac上的一个包管理器，相当于ubantu的apt—get。第一次接触homebrew的同学可以戳官网。 安装过程首先在终端输入如下命令更新Homebrew的package数据库 brew update 更新完毕后，接着输入如下命令进行安装mongodb brew install mongodb 安装完成终端大概会出现如下命令123456789101112==&gt; Downloading https://downloads.sf.net/project/machomebrew/Bottles/mongodb-3.4######################################################################## 100.0%==&gt; Pouring mongodb-3.4.6.mavericks.bottle.2.tar.gz==&gt; CaveatsTo have launchd start mongodb at login:ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgentsThen to load mongodb now:launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mongodb.plistOr, if you don’t want/need launchctl, you can just run:mongod —config /usr/local/etc/mongod.conf==&gt; Summary/usr/local/Cellar/mongodb/3.4.6: 17 files, 331M 好了现在安装完成。 启动mongbd输入命令 mongod --config /usr/local/etc/mongod.conf 然后在终端输入命令 mongo 出现如下命令则表示启动成功 1234567891011MongoDB shell version v3.4.6connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.6Server has startup warnings: 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000&gt; 终端输入exit可以退出数据库终端操作。 关闭mongodb1. 使用数据库命令关闭在 数据库操作的终端 依次输入如下命令：12&gt; use admin&gt; db.shutdownServer() 注意这里命令区分大小写。 2. 使用kill命令关闭新建终端窗口 输入如下命令 ps -ef | grep mongo 这个命令查看关于mongo的所有进程的所有信息。如下是我输入命令显示的信息。其中第二列数据是pid。最后一列显示了当时启动该进程输入的命令。12501 3734 3693 0 5:28下午 ttys000 0:00.00 grep mongo501 3707 3601 0 5:06下午 ttys001 0:06.13 mongod --auth --port 27017 --dbpath /data/db 再使用kill+pid命令关闭mongo运行的进程。 kill 3707 这种方式一般用于强制关闭。不建议使用。 问题1. 启动时WARNING问题我们在一开始使用mongod --config /usr/local/etc/mongod.conf 启动mongodb时，出现了一大堆提示信息，包括了一些warning，如下：122017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 这些warning并不影响使用数据库，但总出现warning看着也很不爽，那这些命令到底是什么呢？怎么解决呢？ 其实，这是新版mongodb要求我们建立一个安全的数据库。对数据库操作权限设置，只能允许授权用户操作制定数据库。在stackoverflow上找到了解决方案。 如果刚刚启动了mongodb请关闭。方法参考上面。 输入如下命令启动mongodb。这里 /data/db是mongodb存放数据的目录。homebrew安装一般会自动创建。1mongod --port 27017 --dbpath /data/db 新建一个终端窗口连接mongodb 1mongo --port 27017 输入如下数据库命令创建用户。 12345678use admindb.createUser( &#123; user: &quot;yourname&quot;, pwd: &quot;yourpwd&quot;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;) 关闭数据库并用如下命令重启。 1mongod --auth --port 27017 --dbpath /data/db 连接数据库。 1mongo --port 27017 -u &quot;yourname&quot; -p &quot;yourpwd&quot; --authenticationDatabase &quot;admin&quot; 好了现在就会发现WARNING不见了。 123MongoDB shell version v3.4.6connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.6 在使用时，如果要指定某个用户对某个数据库的操作，可以创建用户指定权限。 比如 Tester用户对test数据对操作为可读可写。 123456789use testdb.createUser( &#123; user: &quot;Tester&quot;, pwd: &quot;123&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;, &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ] &#125;) 连接数据库的命令就变成了 1mongo --port 27017 -u &quot;Tester&quot; -p &quot;123&quot; --authenticationDatabase &quot;test&quot; 当然如果nodejs使用mongoose操作mongodb时，连接的命令也需要填充一些参数 1mongoose.createConnection(&apos;localhost&apos;, &apos;test&apos;, 27017, &#123;user: &apos;Tester&apos;, pass: &apos;123&apos;&#125;); ###2. 启动或关闭数据库时Exception问题12345[initandlisten] exception in initAndListen: 20 Attempted to create a lock file on a read-only directory: /data/db, terminating[initandlisten] shutdown: going to close listening sockets...[initandlisten] shutdown: going to flush diaglog...[initandlisten] now exiting[initandlisten] shutting down with code:100 这个问题是因为 只有root对 /data/db可写，但是你在用自己的账户操作，所以可以用一下命令授权解决问题。 sudo chmod -R go+w /data/db 或者 sudo chown -R $USER /data/db 好了文章就写到这里。再遇见什么坑和问题会后续补充。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://imwyy.github.io/categories/数据库/"}],"tags":[{"name":"安装和配置","slug":"安装和配置","permalink":"http://imwyy.github.io/tags/安装和配置/"},{"name":"踩坑","slug":"踩坑","permalink":"http://imwyy.github.io/tags/踩坑/"}]}]}