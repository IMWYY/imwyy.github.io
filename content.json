{"meta":{"title":"stpehac的博客","subtitle":null,"description":null,"author":"stpehen","url":"http://imwyy.github.io"},"pages":[{"title":"about","date":"2017-12-11T07:01:23.000Z","updated":"2017-12-11T07:02:18.655Z","comments":true,"path":"about/index.html","permalink":"http://imwyy.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-11T07:01:16.000Z","updated":"2017-12-11T07:01:44.353Z","comments":true,"path":"categories/index.html","permalink":"http://imwyy.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-11T06:44:04.000Z","updated":"2017-12-11T07:02:27.209Z","comments":true,"path":"tags/index.html","permalink":"http://imwyy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"servlet response的encodeURL","slug":"servlet-response的encodeURL","date":"2017-12-25T05:59:24.000Z","updated":"2017-12-25T06:20:06.769Z","comments":true,"path":"2017/12/25/servlet-response的encodeURL/","link":"","permalink":"http://imwyy.github.io/2017/12/25/servlet-response的encodeURL/","excerpt":"","text":"问题与解决初学servlet，一直没在意HttpServletResponse的encodeURL方法，所以服务器端返回地址的时候一直这么写的 123 \"&lt;form action=\\\"\" + req.getContextPath() + \"/\\\" method=\\\"post\\\"&gt;\\n\" 直到运行的时候才发现，这里的请求没有发送到服务器端到相应servlet的doPost方法，但是浏览器检查发现，表单的提交地址确实是对的啊。但是每次点击登录，页面不变，只是刷新了以下登录页面。（这里我 登录的get方法是返回静态页面，post方法是表单提交登录）。 最后突然想起来课上提过一句encodeURL方法，改了以下 123 \"&lt;form action=\\\"\" + resp.encodeURL(req.getContextPath()) + \"/\\\" method=\\\"post\\\"&gt;\\n\" 再试一下，一切正常。 网上搜索后，发现。原来encodeURL方法主要作用是跟踪session， Java Servlet API 中提出了跟踪 Session 的另一种机制，如果客户端浏览器不支持 Cookie，Servlet 容器可以重写客户请求的 URL，把 Session ID 添加到 URL 信息中。 HttpServletResponse 接口提供了重写 URL 的方法：public String encodeURL(java.lang.String url)该方法的实现机制为： 先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。 再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。 也就是说为了实现即使在客户端不支持cookie的情况下（我们都知道session机制的实现需要一般依靠cookie），也能够在通过在url后拼接sessionid的形式跟踪id。所以在用了encodeURL后，支持跟踪session，我写的登录自然也能成功了。 仍有的疑惑还是上面的例子。我写成这样，仍然可以正常运行： 1\"&lt;form action=\\\"/login/\\\" method=\\\"post\\\"&gt;\\n\" 我将地址硬编码到html中，仍然可以正常运行，这是为什么？默认就是encodeURL后的路径吗？","categories":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/categories/java/"}],"tags":[{"name":"java EE","slug":"java-EE","permalink":"http://imwyy.github.io/tags/java-EE/"}]},{"title":"java8新特性总结","slug":"java8新特性总结","date":"2017-12-23T08:51:55.000Z","updated":"2017-12-23T09:15:18.810Z","comments":true,"path":"2017/12/23/java8新特性总结/","link":"","permalink":"http://imwyy.github.io/2017/12/23/java8新特性总结/","excerpt":"","text":"一篇比较详细的文章。戳这里。 概括来说有以下几点： lamada表达式和函数式接口 stream API 流式操作 接口默认实现方法和静态方法 注解的更新 类库的更新，包括 Date API，Base64，支持JavaScript等 关于base64详细戳这里","categories":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/tags/java/"}]},{"title":"java9新特性","slug":"java9新特性","date":"2017-12-23T04:19:46.000Z","updated":"2017-12-23T09:15:41.458Z","comments":true,"path":"2017/12/23/java9新特性/","link":"","permalink":"http://imwyy.github.io/2017/12/23/java9新特性/","excerpt":"","text":"转载自：https://www.oschina.net/translate/java-9-new-features原文：https://www.pluralsight.com/blog/software-development/java-9-new-features 整理和精简如下： 1. Java 平台级模块系统Java 9 的定义功能是一套全新的模块系统。当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长。这时候就得面对两个基础的问题: 很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共类所访问到, 这样就会导致无意中使用了并不想被公开访问的 API。此外，类路径本身也存在问题: 你怎么知晓所有需要的 JAR 都已经有了, 或者是不是会有重复的项呢? 模块系统把这俩个问题都给解决了。 模块化的 JAR 文件都包含一个额外的模块描述器。在这个模块描述器中, 对其它模块的依赖是通过 “requires” 来表示的。另外, “exports” 语句控制着哪些包是可以被其它模块访问到的。所有不被导出的包默认都封装在模块的里面。如下是一个模块描述器的示例，存在于 “module-info.java” 文件中: 12345module blog &#123; exports com.pluralsight.blog; requires cms;&#125; 2. JShell: 交互式 Java REPL许多语言已经具有交互式编程环境，Java 现在加入了这个俱乐部。您可以从控制台启动 jshell ，并直接启动输入和执行 Java 代码。 jshell 的即时反馈使它成为探索 API 和尝试语言特性的好工具。 一个例子： 测试某个功能或使用的时候，不用再打开编辑器，然后写public static void main(String[] args)，方便很多。 3. 集合工厂方法通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 “add” 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：List.of, Set.of。这样构造集合就方便了很多。如： 4.私有接口方法Java 8 为我们带来了接口的默认方法。 接口现在也可以包含行为，而不仅仅是方法签名。 但是，如果在接口上有几个默认方法，代码几乎相同，会发生什么情况？ 通常，您将重构这些方法，调用一个可复用的私有方法。 但默认方法不能是私有的。 将复用代码创建为一个默认方法不是一个解决方案，因为该辅助方法会成为公共API的一部分。 使用 Java 9，您可以向接口添加私有辅助方法来解决此问题： 1234567891011public interface MyInterface &#123; void normalInterfaceMethod(); default void interfaceMethodWithDefault() &#123; init(); &#125; default void anotherDefaultMethod() &#123; init(); &#125; // This method is not part of the public API exposed by MyInterface private void init() &#123; System.out.println(\"Initializing\"); &#125;&#125; 5. HTTP/2Java 9 中有新的方式来处理 HTTP 调用。这个迟到的特性用于代替老旧的 HttpURLConnection API，并提供对 WebSocket 和 HTTP/2 的支持。注意：新的 HttpClient API 在 Java 9 中以所谓的孵化器模块交付。也就是说，这套 API 不能保证 100% 完成。不过你可以在 Java 9 中开始使用这套 API： 123456789HjttpClient client = HttpClient.newHttpClient();HttpRequest req = HttpRequest.newBuilder(URI.create(\"http://www.google.com\")) .header(\"User-Agent\",\"Java\") .GET() .build(); HttpResponse&lt;String&gt; resp = client.send(req, HttpResponse.BodyHandler.asString()); 除了这个简单的请求/响应模型之外，HttpClient 还提供了新的 API 来处理 HTTP/2 的特性，比如流和服务端推送。","categories":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/tags/java/"}]},{"title":"leetcode之wordsearch","slug":"leetcode之wordsearch","date":"2017-12-23T03:20:08.000Z","updated":"2017-12-23T03:30:29.954Z","comments":true,"path":"2017/12/23/leetcode之wordsearch/","link":"","permalink":"http://imwyy.github.io/2017/12/23/leetcode之wordsearch/","excerpt":"","text":"ProblemGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board = 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = “ABCCED”, -&gt; returns true, word = “SEE”, -&gt; returns true, word = “ABCB”, -&gt; returns false. 思考自己考虑采用map记录每个位置的字母，遍历给定的单词字符，比较每个位置是否是相邻。但是不同位置可以出现相同字母，就比较棘手。 又想构建树，一个单词就是一条树中的一条路径。但是跟节点无法确定，如果遍历board每个节点都构造树，未免太麻烦。 Solution1234567891011121314151617181920212223boolean exist(char[][] board, String word) &#123; char[] w = word.toCharArray(); for (int y = 0; y &lt; board.length; y++) &#123; for (int x = 0; x &lt; board[y].length; x++) &#123; if (exist(board, y, x, w, 0)) return true; &#125; &#125; return false; &#125; private boolean exist(char[][] board, int y, int x, char[] word, int i) &#123; if (i == word.length) return true; if (y &lt; 0 || x &lt; 0 || y == board.length || x == board[y].length) return false; if (board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x + 1, word, i + 1) || exist(board, y, x - 1, word, i + 1) || exist(board, y + 1, x, word, i + 1) || exist(board, y - 1, x, word, i + 1); board[y][x] ^= 256; return exist; &#125; 查看了leetcode大神的解答。用了递归。 这里比较巧妙的是board[y][x] ^= 256;，利用异或操作为为每个位置的char记录是否被访问。字母的ascii码小于128，这里异或256即10000000，异或0即是本身，所以低位没变，但是高位改变，没有字母能和异或后的结果相等，也就达到了记录是否被访问的效果，节省空间还方便。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://imwyy.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://imwyy.github.io/tags/leetcode/"}]},{"title":"servlet单例多线程","slug":"servlet单例多线程机制","date":"2017-12-22T11:30:44.000Z","updated":"2017-12-22T12:00:59.555Z","comments":true,"path":"2017/12/22/servlet单例多线程机制/","link":"","permalink":"http://imwyy.github.io/2017/12/22/servlet单例多线程机制/","excerpt":"","text":"转载自：https://www.cnblogs.com/yjhrem/articles/3160864.html 将原文进行了修整和精简 Servlet如何处理多个请求访问？Servlet容器默认是采用单实例多线程的方式处理多个请求的： 当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化(只存在一个Servlet实例) 容器初始化化Servlet主要就是读取配置文件（例如tomcat,可以通过servlet.xml的设置线程池中线程数目，初始化线程池通过web.xml,初始化每个参数值等等。 当请求到达时，Servlet容器通过调度线程(Dispatchaer Thread) 调度它管理下线程池中等待执行的线程（Worker Thread）给请求者 线程执行Servlet的service方法 请求结束，放回线程池，等待被调用（注意：避免使用实例变量（成员变量），因为如果存在成员变量，可能发生多线程同时访问该资源时，都来操作它，照成数据的不一致，因此产生线程安全问题） 从上面可以看出： 第一：Servlet单实例，减少了产生servlet的开销； 第二：通过线程池来响应多个请求，提高了请求的响应时间； 第三：Servlet容器并不关心到达的Servlet请求访问的是否是同一个Servlet还是另一个Servlet，直接分配给它一个新的线程；如果是同一个Servlet的多个请求，那么Servlet的service方法将在多线程中并发的执行； 第四：每一个请求由ServletRequest对象来接受请求，由ServletResponse对象来响应该请求； 如何开发线程安全的Servlet 实现 SingleThreadModel 接口 该接口指定了系统如何处理对同一个Servlet的调用。如果一个Servlet被这个接口指定,那么在这个Servlet中的service方法将不会有两个线程被同时执行，当然也就不存在线程安全的问题。 如果一个Servlet实现了SingleThreadModel接口，Servlet引擎将为每个新的请求创建一个单独的Servlet实例，这将引起大量的系统开销。SingleThreadModel在Servlet2.4中已不再提倡使用 同步对共享数据的操作 使用synchronized 关键字能保证一次只有一个线程可以访问被保护的区段，在本论文中的Servlet可以通过同步块操作来保证线程的安全 避免使用实例变量 本实例中的线程安全问题是由实例变量造成的，只要在Servlet里面的任何方法里面都不使用实例变量，那么该Servlet就是线程安全的。","categories":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/categories/java/"}],"tags":[{"name":"java EE","slug":"java-EE","permalink":"http://imwyy.github.io/tags/java-EE/"}]},{"title":"servlet的filter使用替换流","slug":"servlet的filter使用替换流","date":"2017-12-22T04:59:22.000Z","updated":"2017-12-22T11:31:34.240Z","comments":true,"path":"2017/12/22/servlet的filter使用替换流/","link":"","permalink":"http://imwyy.github.io/2017/12/22/servlet的filter使用替换流/","excerpt":"","text":"servlet过滤器工作流程 servlet过滤器在request到达servlet前可以拦截，在response到达客户端之前可以捕获。这样便可以在过滤器中处理一些请求响应的前置操作或通用操作。 常见的一种应用就是进行敏感词过滤。 但是如果直接使用HttpServletResponse，这是一个流，无法对已经out.println()的内容进行修改。所以这里需要替代流。 替代流（stand-in stream）原理在请求到达servlet之前拦截HttpServletResponse，将HttpServletResponse封装成替代流，之后servlet操作的对象即是这个封装后的替代流。这里的封装本质上就是建立一个输出缓冲区，servlet的所有输出都输出到了这个缓冲区，并没有直接写入真正的HttpServletResponse。 然后在响应返回阶段，捕获之前封装的HttpServletResponse，然后将servlet中输出到缓冲区的内容，进行敏感词过滤。 实现利用HttpServletResponseWrapper包装HttpServletResponse，并重写输出流的方法。 一种实现方法如下： 12345678910111213141516171819public class BufferedResponse extends HttpServletResponseWrapper &#123; private PrintWriter printWriter; private CharArrayWriter charArrayWriter; public BufferedResponse(HttpServletResponse response) &#123; super(response); charArrayWriter = new CharArrayWriter(); printWriter = new PrintWriter(bufferedWriter); &#125; @Override public PrintWriter getWriter() &#123; return printWriter; &#125; public String getOutput() &#123; return charArrayWriter.toString(); &#125; &#125; 过滤器中使用： 1234567891011@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; BufferedResponse bufferedResponse = new BufferedResponse(servletResponse); // filterChain.doFilter 这里指继续处理后续步骤 filterChain.doFilter(servletRequest, bufferedResponse); //这里servlet已经处理完，output即servlet的输出，在这里替换敏感词 String output = bufferedResponse.getOutput(); &#125; 以及如果对CharArrayWriter陌生，点击这里 CharArrayWriter","categories":[{"name":"java","slug":"java","permalink":"http://imwyy.github.io/categories/java/"}],"tags":[{"name":"java EE","slug":"java-EE","permalink":"http://imwyy.github.io/tags/java-EE/"}]},{"title":"android.content.res.Resources$NotFoundException","slug":"android.content.res.Resources$NotFoundException","date":"2017-12-21T12:57:48.000Z","updated":"2017-12-21T13:02:56.281Z","comments":true,"path":"2017/12/21/android.content.res.Resources$NotFoundException/","link":"","permalink":"http://imwyy.github.io/2017/12/21/android.content.res.Resources$NotFoundException/","excerpt":"","text":"Android报“android.content.res.Resources$NotFoundException: String resource ID xxx”错误错误情形使用TextView的setText方法，报错资源找不到。 1.setText(R.id.read_num,item.getReadNum()) 解决这里item.getReadNum()是一个int，setText方法如果直接穿一个数字参数，会被当作是资源id，定位该资源发现找不到就会爆粗。所以只要转成字符串就可以了。1.setText(R.id.read_num, “” + item.getReadNum())","categories":[{"name":"踩坑","slug":"踩坑","permalink":"http://imwyy.github.io/categories/踩坑/"}],"tags":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/tags/android/"},{"name":"踩坑","slug":"踩坑","permalink":"http://imwyy.github.io/tags/踩坑/"}]},{"title":"自定义圆角的textview","slug":"自定义圆角的textview","date":"2017-12-19T13:44:27.000Z","updated":"2017-12-19T15:29:56.538Z","comments":true,"path":"2017/12/19/自定义圆角的textview/","link":"","permalink":"http://imwyy.github.io/2017/12/19/自定义圆角的textview/","excerpt":"","text":"给textview添加圆角如果想给一个普通的textview添加圆角、边框等，一般的做法是写一个drawable文件，通过android:background=&quot;@drawable/xxxx&quot;设置为textview的背景。麻烦是不麻烦，可是如果项目里出现了很多需要圆角或者边框的需求时，drawable文件会变得很多很乱，维护起来也十分不方便。 如果直接可以通过属性设置radius border borderWidth等属性值，就会方便很多。github上有一个 SuperTextView ，可以实现。但是功能太多太杂了。搜了搜网上的写法，基本都是重新定义view，重写onDraw onMeasure ，可是这些功能textview都有，没必要，况且重写之后，textview的很多功能就没了。 这里的思路是，通过继承TextView来自定义Textview，利用代码来控制drawable文件。代码创建drawable文件的方式如下： 自定义view的方式有三种：组合、继承、完全自定义 123GradientDrawable gd = new GradientDrawable();//创建drawablegd.setColor(rtvBgColor);gd.setCornerRadius(rtvRadius); 所以方法就是，自定义属性，通过属性值创建drawable文件控制圆角、边框等。如果不设置自定义属性，和一个普通TextView没有任何差别！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 支持圆角的TextView * Created by stephen on 2017/12/18. */public class RoundTextView extends android.support.v7.widget.AppCompatTextView &#123; public RoundTextView(Context context) &#123; this(context, null); &#125; public RoundTextView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RoundTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs, R.styleable.RoundTextView, defStyleAttr, 0); if (attributes != null) &#123; int rtvBorderWidth = attributes.getDimensionPixelSize(R.styleable.RoundTextView_rtvBorderWidth, 0); int rtvBorderColor = attributes.getColor(R.styleable.RoundTextView_rtvBorderColor, Color.BLACK); float rtvRadius = attributes.getDimension(R.styleable.RoundTextView_rtvRadius, 0); int rtvBgColor = attributes.getColor(R.styleable.RoundTextView_rtvBgColor, Color.WHITE); attributes.recycle(); GradientDrawable gd = new GradientDrawable();//创建drawable gd.setColor(rtvBgColor); gd.setCornerRadius(rtvRadius); if (rtvBorderWidth &gt; 0) &#123; gd.setStroke(rtvBorderWidth, rtvBorderColor); &#125; this.setBackground(gd); &#125; &#125; public void setBackgroungColor(@ColorInt int color) &#123; GradientDrawable myGrad = (GradientDrawable) getBackground(); myGrad.setColor(color); &#125;&#125; 在attr中添加属性 1234567&lt;!--支持圆角的TextView--&gt;&lt;declare-styleable name=\"RoundTextView\"&gt; &lt;attr name=\"rtvBgColor\" format=\"color\"/&gt; &lt;attr name=\"rtvBorderWidth\" format=\"dimension\"/&gt; &lt;attr name=\"rtvBorderColor\" format=\"dimension\"/&gt; &lt;attr name=\"rtvRadius\" format=\"dimension\"/&gt;&lt;/declare-styleable&gt; 代码使用 12345678&lt;io.github.imwyy.RoundTextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:text=\"浏览\" android:textColor=\"@color/text_black_select_color\" android:textSize=\"@dimen/sp_14\" app:rtvRadius=\"6dp\" app:rtvBgColor=\"@color/colorSearchArea\"/&gt; 这样显然就方便很多了。","categories":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/tags/android/"},{"name":"踩坑","slug":"踩坑","permalink":"http://imwyy.github.io/tags/踩坑/"}]},{"title":"数据结构之树","slug":"数据结构之树","date":"2017-12-19T03:39:13.000Z","updated":"2017-12-19T15:33:52.053Z","comments":true,"path":"2017/12/19/数据结构之树/","link":"","permalink":"http://imwyy.github.io/2017/12/19/数据结构之树/","excerpt":"","text":"二叉树 每个结点最多有两颗子树，结点的度最大为2 左子树和右子树是有顺序的，次序不能颠倒 节点数为n的树 深度至多为n 至少为log2(n+1)向下取整 对于任何一棵非空的二叉树,如果叶节点个数为n0，度数为2的节点个数为n2，则有: n0 = n2 + 1 存储二叉树结构的方法一般有三种，数组、链表、游标 满二叉树高度为h的满二叉树拥有刚刚好(2^h+1 )-1个节点 完全二叉树若二叉树高度为h，除h层外其他所有层节点个数都达到了最大个数。若h层有叶节点，则所有的叶节点从左到右排列。这就是完全二叉树 具有n的结点的完全二叉树的深度为log2n+1. 如果有一颗有n个节点的完全二叉树的节点按层次序编号，对任一层的节点i（1&lt;=i&lt;=n）有 如果i=1，则节点是二叉树的根，无双亲，如果i&gt;1，则其双亲节点为[i/2]，向下取整 如果2i&gt;n那么节点i没有左孩子，否则其左孩子为2i 如果2i+1&gt;n那么节点没有右孩子，否则右孩子为2i+1 tips: 编号后，左子节点的编号是父节点编号的两倍 参考 二叉树的遍历 前序遍历:根—左—右。 递归实现 非递归实现 思路：每次访问树的左节点，并将节点入栈。如果左节点为空，就取栈顶出栈，访问栈顶节点的右节点，并继续访问入栈访问左节点。代码如下： 12345678910111213141516void preOrderTraverse(Tree t) &#123; Stack s; Tree tmp = t; while((tmp != NULL) || !isEmpty(&amp;s)) &#123; while(tmp != NULL) &#123; Push(&amp;s, tmp); visit(&amp;tmp); tmp = tmp-&gt;lchild; &#125; if(!isEmpty(&amp;s)) &#123; Pop(&amp;s, &amp;tmp); tmp = tmp-&gt;rchild; &#125; &#125;&#125; 中序遍历: 左-根-右 递归实现 非递归实现 若其左孩子不为空，则将t入栈，并将t的左孩子设置为当前的t 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该结点。然后将当前的t置为栈顶结点的右孩子 直到t为空并且栈为空，则遍历结束。 1234567891011121314151617void inOrderTraverse(Tree t) &#123; Stack s; Tree tmp = t; while((tmp != NULL) || !isEmpty(&amp;s)) &#123; while(tmp != NULL) &#123; Push(&amp;s, tmp); tmp = tmp-&gt;lchild; &#125; if(!isEmpty(&amp;s)) &#123; Pop(&amp;s, &amp;tmp); visit(&amp;tmp); tmp = tmp-&gt;rchild; &#125; &#125;&#125; 后序遍历: 左-右-根 递归实现 非递归实现 确保在访问父节点之前左右子节点都已经被访问。当前节点如果没有子节点，或者当前节点的子节点都被访问的时候，可以访问当前节点。否则将当前节点的子节点入栈。 12345678910111213141516171819202122232425void postOrderTraverse(Tree t) &#123; Stack s; Tree cur = NULL; Tree pre = NULL; Push(&amp;s, t); while(!isEmpty(&amp;s) &#123; Top(&amp;s, &amp;cur); if((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL)) || (cur-&gt;lchild == NULL &amp;&amp; pre != NULL &amp;&amp; pre == cur-&gt;rchild) || (cur-&gt;rchild == NULL &amp;&amp; pre != NULL &amp;&amp; pre == cur-&gt;lchild)) &#123; Pop(&amp;s, &amp;cur); visit(cur); pre = cur; &#125; else &#123; if(cur-&gt;lchild) &#123; Push(&amp;s, cur-&gt;lchild); &#125; if(cur-&gt;rchild) &#123; Push(&amp;s, cur-&gt;rchild); &#125; &#125; &#125; &#125;&#125; 二叉树的创建 使用访问序列建立二叉树，如 先序:ABDCEGFHI 中序:DBAEGCHFI tips: 如果仅仅知道二叉树的先序遍历和后序遍历，无法确定二叉树 使用广义表来构造，如：A(B(D), C(E( ,G), F(H,I))) 线索树n个结点的二叉树有2n个链域，其中真正有用的是n – 1个，其它n + 1个都是空域。 为了充分利用结点中的空域，使得对某些运算更快，如前驱或后继等运算。 二叉树的应用：霍夫曼编码参考链接","categories":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/categories/干货/"}],"tags":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/tags/干货/"}]},{"title":"glide缓存无法更新","slug":"glide缓存无法更新","date":"2017-12-15T01:47:10.000Z","updated":"2017-12-15T02:10:06.438Z","comments":true,"path":"2017/12/15/glide缓存无法更新/","link":"","permalink":"http://imwyy.github.io/2017/12/15/glide缓存无法更新/","excerpt":"","text":"问题使用glide加载图片，glide有缓存，分为内存缓存和磁盘缓存，可以通过diskCacheStrategy设置不同的缓存策略。具体可以看官方文档（我使用的是glideV4 国内的介绍还比较少）。但是对于指定的url的图片，会出现服务器端的图片已经改变，但是本地加载的时候，glide发现有缓存，不会重新从服务器加载，导致一直显示老的图片。 解决 如果将diskCacheStrategy设置为NONE，内存缓存依然存在。可以设置 skipMemoryCache(true)，这样每次加载都会从服务器重新加载。但是这样耗费流量，加重服务器负担。不好。 翻阅官方文档发现glide有个signature，就是为了解决这个问题。因为glide缓存是采&lt;K, V&gt;键值对存储，如果加载一个url的图片，K就是url，url不变，那么缓存V也不会变。signature的作用就是可以在K上附加一写Key，也就是我们可以在加载图片的时候，存储一个表明当前版本的时间戳，当更新时，改变时间戳，时间戳改变也就是K改变，那么就会重新加载图片。 具体实现如下： 加载图片，根据sp时间戳添加signature： 1234567GlideApp.with(view.getContext()) .load(AppConstants.URL_USER_HEAD + uid) .signature(new ObjectKey(SPUtils.getInstance(AppConstants.SP_NAME_USER).getString(\"head_signature\", \"\"))) .diskCacheStrategy(DiskCacheStrategy.AUTOMATIC) .placeholder(R.drawable.user_default_head) .error(R.drawable.user_default_head) .into(view); 更新图片时，同时更新sp的时间戳： 12SPUtils.getInstance(AppConstants.SP_NAME_USER) .put(\"head_signature\",String.valueOf(System.currentTimeMillis())); 这里有个不知道是不是问题的问题，每次加载都要读取sp，可能会有影响。 注意官方文档有一句话 Urls - Although the best way to invalidate urls is to make sure the server changes the url and updates the client when the content at the url changes, you can also use ObjectKey to mix in arbitrary metadata (such as a version number) instead. 也就是说最好的方式就是让服务器加一个时间戳，可是这样实现起来可能就不是很简单。暂时没有尝试。尝试了再来补充。先记下了。","categories":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/categories/android/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"http://imwyy.github.io/tags/踩坑/"}]},{"title":"android干货集","slug":"android干货集","date":"2017-12-13T01:32:49.000Z","updated":"2017-12-19T15:30:34.301Z","comments":true,"path":"2017/12/13/android干货集/","link":"","permalink":"http://imwyy.github.io/2017/12/13/android干货集/","excerpt":"","text":"glide使用glide和Picasso的区别ConstraintLayout解析","categories":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/tags/android/"},{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/tags/干货/"}]},{"title":"alfred的workflow","slug":"alfred的workflow","date":"2017-12-12T07:58:41.000Z","updated":"2017-12-14T09:00:52.077Z","comments":true,"path":"2017/12/12/alfred的workflow/","link":"","permalink":"http://imwyy.github.io/2017/12/12/alfred的workflow/","excerpt":"","text":"关于alfred之前也一直使用被称为mac神器到alfred。直到今天才发现我用的是低版本，功能非常基础。而高版本所支持的workflow才是真的称为神器。alfred下载猛戳这里这里。至于powerpack的一些功能，可以选择购买使用或者…（滑稽脸） workflowworkflow就是让alfred直接执行脚本，包括shell、python、php等，直接那两个例子来解释，就知道他有多方便了。 登录校园网（使用python脚本）在之前用旧版本的alfred登录校园网所用的方法是在feature添加web url，输入p打开p.nju.edu.cn。然后点击输入浏览器记住的密码登陆。相比打开浏览器页面已经快捷很多。但是如果使用workflow可以直接，输入指定内容，回车就可以登陆。具体定义该workflow的步骤如下： preference中点击workflow,按照如图选择keyword to script 输入关键字和描述，保存 右键创建script 输入执行的脚本并保存 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import jsonimport urllibimport urllib2def login(): url = 'http://p.nju.edu.cn/portal_io/login' username = 'xxxx' # 可将密码等保存至文件 password = 'xxxxx' data = &#123;'username': username, 'password': password&#125; postdata = urllib.urlencode(data).encode('utf-8') try: request = urllib2.Request(url, postdata) response = urllib2.urlopen(request) res = json.loads(response.read().decode('utf-8')) # print res[\"reply_code\"] except Exception as e: print(e)if __name__ == '__main__': login() 快捷键打开alfred输入框，输入你的关键字，回车。就连上了校园网。 更新 2017-12-14可以添加快捷键和通知提醒！！！！ 简直方便到炸，快捷键‘opt+p’登录，‘opt+o’退出登录。每次操作完成可以有提示音和notification。连alfred都不用打开！！！ 具体操作看github 部署hexo博客（使用shell脚本）一般部署hexo博客要输入三条命令hexo clean hexo g hexo d。每次都要打开终端输入三个命令真的很麻烦，进阶方法是将命令写成shell脚本，打开终端执行./xxx.sh。当然也可以利用alfred，连终端都不用自己打开。 1 2 3步骤和上个例子一样，不过第四步选择terminal command 然后输入脚本 1cd 你的博客本地目录 &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 写完博客，快捷键打开alfred输入框，输入你定义的关键字，回车。部署完成。同理也可以将博客创建的几条命令放在shell脚本用workflow打开。 问题照理说命令应该选择script，但是不奏效，debug（workflow页面有个小虫子，就是debug）发现找不到hexo命令，我明明安装的是全局hexo命令。所以选择terminal command。找到原因了再来改。","categories":[{"name":"小玩意","slug":"小玩意","permalink":"http://imwyy.github.io/categories/小玩意/"}],"tags":[{"name":"小玩意","slug":"小玩意","permalink":"http://imwyy.github.io/tags/小玩意/"}]},{"title":"数据库索引","slug":"数据库索引","date":"2017-12-12T03:03:39.000Z","updated":"2017-12-19T15:30:17.348Z","comments":true,"path":"2017/12/12/数据库索引/","link":"","permalink":"http://imwyy.github.io/2017/12/12/数据库索引/","excerpt":"","text":"1.范式与反范式1.1 范式 第一范式 符合1NF的关系中的每个属性都不可再分，是所有关系型数据库的最基本要求 第二范式 数据表里的所有非主属性都要和该数据表的主键有完全依赖关系；如果有哪些非主属性只和主键的一部份有关的话，它就不符合第二范式；如果一个数据表的主键只有单一一个字段的话，它就一定符合第二范式 第三范式 指数据库中不能存在传递函数依赖关系；关系（表）中的非主属性（非关键字段）不存在对候选键的传递依赖的性质，也指每个非主属性都独立于其他非主属性，并依赖于候选键。 1.2 反范式 范式的满足便于数据一致性的控制，数据冗余会导致数据一致性的控制变得复杂。规范化的数据都是低效的。引入可以控制的冗余可以提高数据库性能 所有的冗余都是为了减少表连接的数量，使用触发器可以解决冗余导致的数据不一致（但是触发器可能会导致循环更改） 数据库反范式设计的七种情形 合并一对一关系 如果双方都是完全参与，那么某个表直接可以作为另一张表的属性直接合并。若有一方是部分参与，把完全参与的并入部分参与的会出现空值，将部分参与并入完全参与的可以。若双方都是部分参与，一定会出现空值，这样就很难确定主键。 拷贝一对多关系中的非主键值 一部电影可能有多个录像带出租某个录像带的日租金时，需要查询video表获得该电影的租金。解决方案是在录像带表添加一个租金字段，并设置触发器 拷贝一对多关系中的外键 拷贝多对多关系中的属性 演员演某一步电影，role表只记录了catelogNo和actorNo，如果要查电影名字就比较困难。role表添加一个电影名称属性。 引入重复组 常见做法：在customer表中引入一条addr字段，放最常用地址，address表中存储所有地址 创建提取表 适用查询实时性不高的情况。。extract table的表中内容和原表可能都相同，只是组织结构不同，有可能一个是为了车查询而建的表（将经常被查询的数据提前计算出来存入该表，会有大量冗余，但是提高效率），另一个是为了update的，一定程度上实现了读写分离。 分区表 将表分成小部分的分区。水平分区：将记录分在不同的表中；竖直分区：将属性分在不同的表中，主键重复。分区对于存储和分析大量数据的应用有好处。 2.索引###2.1 索引概念 索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。是一种以原子粒度访问数据的手段，而不是为了大量数据的访问。是一种数据访问方式；索引是顺序存取。 索引分类 聚簇索引：按照数据存放的物理位置为顺序的，索引的叶节点就是物理上的叶节点，聚簇索引能提高多行检索的速度 非聚簇索引；索引顺序与数据物理排列顺序无关，叶节点仍然是索引节点，保留一个指针指向数据块，非聚簇索引对于单行的检索很快。 一个表最多只能有一个聚簇索引 索引使用时的考虑 检索比率，一般适用于满足条件的数据量少的情况 磁盘访问，内存访问，记录存储 索引与外键 如果没有外键和引用的话，一次修改会导致多次修改 大系统普遍取消外键的关联，取消参照完整性（降低在更新主表时候的过多引用）是提高数据库性能的一个措施。如果有大量的外键关联，则做一次主表查询可能会导致连接多个代码表 索引建立必须要有理由，无论是外键还是其他字段，并不是外键都要添加索引。如果该外键不经常使用就不用添加索引。 如果系统为外键自动添加索引，常常会导致同一字段属于多个索引，为每个外键建立索引，会导致多余索引 系统生成键 系统生成键远好于寻找当前最大值并加1；好于用一个专用表保存下一个值“且加锁更新” 系统生成键是串行插入 如果插入并发性过高，在主键索引的创建操作上会发生严重的资源竞争 解决方案：反向键索引（逆向索引）；哈希索引 系统生成键使用数字比使用字符串效率高 不使用系统生成键，可能会导致插入时主键取值不唯一，有利于主键的唯一性 ###2.2 索引的优点，为什么使用索引？ 什么时候使用B树索引： 仅当要通过索引访问表中很少一部分行 如果要处理表中多行，而且可以使用索引而不用表 索引的5种优点 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显着减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 应该建立索引的条件 在经常需要搜索的列上，可以加快搜索的速度； 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；外键建索引由于连接加快还会减少死锁几率。 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 ###2.3 索引的局限性（索引的限制） 为什么不为每一列建立索引 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引会带来的问题 索引有可能降低查询性能，带来磁盘空间的开销和处理开销等 太多的索引，让设计不稳定 对于大量数据检索，索引效率反而更低 创建索引会带来系统的维护和空间的开销 数据修改需求大于检索需求时，索引会降低性能 这些列不应该建立索引 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 为什么没有使用我的索引？（不使用索引的情况） 主要是因为：使用索引反而得不到正确结果；或使查询效率变得更慢 情况1：我们在使用B+树索引，而且谓词中没有使用索引的最前列表T，T(X,Y)上有索引，做SELECT * FROM T WHERE Y=5·跳跃式索引（仅CBO） 情况2：使用SELECT COUNT(*) FROM T，而且T上有索引，但是优化器仍然全表扫描，不带任何条件的count会引起全表扫描。 情况3：对于一个有索引的列作出函数查询Select * from t where f(indexed_col) = value 情况4：隐形函数查询（主要是时间和类型变化这种隐形函数查询） 不等于符”&lt;&gt;”会限制索引，引起全表扫描，如果改成or就可以使用索引了。 is null查询条件也会屏蔽索引。 情况5：此时如果用了索引，实际反而会更慢。 数据量本来不够大，oracle自己计算后认为不用索引更合算，则CBO不会选择用索引 情况6：没有正确的统计信息，造成CBO无法做出正确的选择；如果查询优化器认为所有会使查询变慢，则不会使用索引表分析就是收集表和索引的信息，生成的统计信息会存在user_tables这个视图。CBO根据这些信息决定SQL最佳的执行路径。 其他： 对于两个公有字段的表，如果在做外表的表上对该字段建立索引，则该索引不会被使用因为外表的数据访问方式是全表扫描。 查询使用了两个条件用or连接，如果条件1中的字段有索引而条件2中字段没有，则仍会全表扫描。 2.4 IOT 索引组织表索引底层实现 mysql采用B+树而不是B树的原因 索引组织表 OT的用途:全索引表，代码查找表，高频度的一组 关联数据查询 IOT最大的优点:记录是排序的…(效率惊人) 2.5 其他索引 位图索引 主要针对大量相同值的列而创建(例如：类别，操作员，部门ID,库房ID等),索引块的一个索引行中存储键值和起止Rowid,以及这些键值的位置编码,位置编码中的每一位表示键值对应的数据行的有无.一个块可能指向的是几十甚至成百上千行数据的位置.这种方式存储数据,相对于B*Tree索引,占用的空间非常小,创建和使用非常快。 位图索引：非常紧凑，块变得复杂，更新操作会导致整个块被锁住，不利于更新，所以创建位图索引的目的是为了查询而不是为了更行B树索引不能存空值，位图索引可以存空值 哈希索引 所谓Hash索引，实际上就是通过一定的Hash算法，将需要索引的键值进行Hash运算，然后将得到的Hash值存入一个Hash表中。每次需要检索的时候，都会将检索条件进行相同算法的Hash运算，再和Hash表中的Hash值进行比较，并得出相应的信息。HASH索引在有限制条件(需要指定一个确定的值而不是一个值范围)的情况下非常有用。 函数索引 基于函数的索引，类似于普通的索引，只是普通的索引是建立在列上，而它是建立在函数上。当然这回对插入数据有一定影响，因为需要通过函数计算一下，然后生成索引。但是插入数据一般都是少量插入，而查询数据一般数据量比较大。 倒排索引 常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://imwyy.github.io/categories/数据库/"}],"tags":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/tags/干货/"},{"name":"数据库","slug":"数据库","permalink":"http://imwyy.github.io/tags/数据库/"}]},{"title":"干货集","slug":"干货","date":"2017-12-11T06:39:36.000Z","updated":"2017-12-23T08:50:35.770Z","comments":true,"path":"2017/12/11/干货/","link":"","permalink":"http://imwyy.github.io/2017/12/11/干货/","excerpt":"","text":"HTTP HTTP报文GET和POST请求的区别HTTP2.0TCP/IP","categories":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/categories/干货/"}],"tags":[{"name":"干货","slug":"干货","permalink":"http://imwyy.github.io/tags/干货/"}]},{"title":"rxjava2的disposable","slug":"rxjava2的disposable","date":"2017-12-10T14:54:06.000Z","updated":"2017-12-19T15:32:11.634Z","comments":true,"path":"2017/12/10/rxjava2的disposable/","link":"","permalink":"http://imwyy.github.io/2017/12/10/rxjava2的disposable/","excerpt":"","text":"rxjava+retrofit处理网络请求在使用rxjava+retrofit处理网络请求的时候，一般会采用对观察者进行封装，实现代码复用和拓展。一种可行的封装如下： 基类observer 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class BaseObserver&lt;T&gt; implements Observer&lt;T&gt; &#123; protected String errMsg = \"\"; protected Disposable disposable; @Override public void onSubscribe(Disposable d) &#123; disposable = d; &#125; @Override public void onNext(T t) &#123; &#125; @Override public void onError(Throwable e) &#123; LogUtils.d(\"Subscriber onError\", e.getMessage()); if (!NetworkUtils.isConnected()) &#123; errMsg = \"网络连接出错,\"; &#125; else if (e instanceof APIException) &#123; APIException exception = (APIException) e; errMsg = exception.getMessage() + \", \"; &#125; else if (e instanceof HttpException) &#123; errMsg = \"网络请求出错,\"; &#125; else if (e instanceof IOException) &#123; errMsg = \"网络出错,\"; &#125; if (disposable != null &amp;&amp; !disposable.isDisposed()) &#123; disposable.dispose(); &#125; &#125; @Override public void onComplete() &#123; if (disposable != null &amp;&amp; !disposable.isDisposed()) &#123; disposable.dispose(); &#125; &#125;&#125; 封装请求（登录为例） 这里userService是retrofit接口类 123456789101112 /** * 登录 * @param phone 账号 * @param password 密码 * @param observer 观察者 */ public void login(String phone, String password, BaseObserver&lt;ResponseBean&lt;UidBean&gt;&gt; observer) &#123;// userService.login(new RequestUserBean(phone, EncryptUtils.encryptMD5ToString(password))) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(observer); &#125; 方法调用 1234567891011121314151617APIUser.getInstance().login(phone, password, new BaseObserver&lt;ResponseBean&lt;UidBean&gt;&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; addDisposable(d); &#125; @Override public void onNext(ResponseBean&lt;UidBean&gt; responseBean) &#123; ToastUtils.showShort(\"登录成功\"); &#125; @Override public void onError(Throwable e) &#123; super.onError(e); ToastUtils.showShort(errMsg+\"登录失败\"); &#125; &#125;); 网上大家对rxjava+retrofit好的封装很多，我这里不再赘述。 关于disposablerxjava虽然好用，但是总所周知，容易遭层内存泄漏。也就说在订阅了事件后没有及时取阅，导致在activity或者fragment销毁后仍然占用着内存，无法释放。而disposable便是这个订阅事件，可以用来取消订阅。但是在什么时候取消订阅呢？我知道有两种方式: 使用CompositeDisposable 看源码，CompositeDisposable的介绍很简单 A disposable container that can hold onto multiple other disposables and offers O(1) add and removal complexity. 一个disposable的容器，可以容纳多个disposable，添加和去除的复杂度为O(1)。这里需要注意的是在该类的addAll方法有这么一句注释 Atomically adds the given array of Disposables to the container or disposes them all if the container has been disposed 也就是说，如果这个CompositeDisposable容器已经是处于dispose的状态，那么所有加进来的disposable都会被自动切断。 所以说可以创建一个BaseActivity，用CompositeDisposable来管理订阅事件disposable，然后在acivity销毁的时候，调用compositeDisposable.dispose()就可以切断所有订阅事件，防止内存泄漏。 在oError和onComplete后调用disposable.dispose();，也就是上面我给的例子中的方法。 查看源码，ObservableCreate的静态类CreateEmitter就是这种方式实现的。同时也可以看到，onError和onComplete不可以同时调用的原因：每次掉用过onError或onComplete其中一个方法后，就会掉用dispose()方法，此时订阅取消，自然也就不能掉用另一个方法了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static final class CreateEmitter&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements ObservableEmitter&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = -3434801548987643227L; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; @Override public void onError(Throwable t) &#123; if (t == null) &#123; t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); &#125; if (!isDisposed()) &#123; try &#123; observer.onError(t); &#125; finally &#123; dispose(); &#125; &#125; else &#123; RxJavaPlugins.onError(t); &#125; &#125; @Override public void onComplete() &#123; if (!isDisposed()) &#123; try &#123; observer.onComplete(); &#125; finally &#123; dispose(); &#125; &#125; &#125; @Override public void setDisposable(Disposable d) &#123; DisposableHelper.set(this, d); &#125; @Override public void setCancellable(Cancellable c) &#123; setDisposable(new CancellableDisposable(c)); &#125; @Override public ObservableEmitter&lt;T&gt; serialize() &#123; return new SerializedEmitter&lt;T&gt;(this); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125; &#125; 除此之外，在github发现一个开源库RxLifecyclee，粗略了解发现他实现的原理是绑定acvitvity是生命周期，在onStart中绑定就在onStop中解绑，其他onResume，onCreate同理。这个和第一种方式似乎又差不多，只不过第一种方式简单，只在ondestory的时候销毁所有事件。 所以那两种方法哪种更好，我也不是很清楚。等到踩到什么坑了可能就知道了。如果某位大佬知道，希望不吝指教。","categories":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://imwyy.github.io/tags/android/"}]},{"title":"安装配置mongoDB","slug":"安装配置mongoDB","date":"2017-12-09T12:27:36.000Z","updated":"2017-12-10T11:16:42.465Z","comments":true,"path":"2017/12/09/安装配置mongoDB/","link":"","permalink":"http://imwyy.github.io/2017/12/09/安装配置mongoDB/","excerpt":"","text":"最近在在学习nodejs，相比mysql，mongodb与nodejs搭配更合适，存储数据格式也比较接近JS对象。关于mysql和mongodb两种类型数据库的差别与对比，下篇文章再写。下面来看一下如何在mac上安装mongodb。 Homebrew你可以选择选择下载mongodb源码编译安装，当然在mac上更方便快捷的方式是用homebrew安装。homebrew是mac上的一个包管理器，相当于ubantu的apt—get。第一次接触homebrew的同学可以戳官网。 安装过程首先在终端输入如下命令更新Homebrew的package数据库 brew update 更新完毕后，接着输入如下命令进行安装mongodb brew install mongodb 安装完成终端大概会出现如下命令123456789101112==&gt; Downloading https://downloads.sf.net/project/machomebrew/Bottles/mongodb-3.4######################################################################## 100.0%==&gt; Pouring mongodb-3.4.6.mavericks.bottle.2.tar.gz==&gt; CaveatsTo have launchd start mongodb at login:ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgentsThen to load mongodb now:launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mongodb.plistOr, if you don’t want/need launchctl, you can just run:mongod —config /usr/local/etc/mongod.conf==&gt; Summary/usr/local/Cellar/mongodb/3.4.6: 17 files, 331M 好了现在安装完成。 启动mongbd输入命令 mongod --config /usr/local/etc/mongod.conf 然后在终端输入命令 mongo 出现如下命令则表示启动成功 1234567891011MongoDB shell version v3.4.6connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.6Server has startup warnings: 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] 2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000&gt; 终端输入exit可以退出数据库终端操作。 关闭mongodb1. 使用数据库命令关闭在 数据库操作的终端 依次输入如下命令：12&gt; use admin&gt; db.shutdownServer() 注意这里命令区分大小写。 2. 使用kill命令关闭新建终端窗口 输入如下命令 ps -ef | grep mongo 这个命令查看关于mongo的所有进程的所有信息。如下是我输入命令显示的信息。其中第二列数据是pid。最后一列显示了当时启动该进程输入的命令。12501 3734 3693 0 5:28下午 ttys000 0:00.00 grep mongo501 3707 3601 0 5:06下午 ttys001 0:06.13 mongod --auth --port 27017 --dbpath /data/db 再使用kill+pid命令关闭mongo运行的进程。 kill 3707 这种方式一般用于强制关闭。不建议使用。 问题1. 启动时WARNING问题我们在一开始使用mongod --config /usr/local/etc/mongod.conf 启动mongodb时，出现了一大堆提示信息，包括了一些warning，如下：122017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2017-08-02T16:21:45.890+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 这些warning并不影响使用数据库，但总出现warning看着也很不爽，那这些命令到底是什么呢？怎么解决呢？ 其实，这是新版mongodb要求我们建立一个安全的数据库。对数据库操作权限设置，只能允许授权用户操作制定数据库。在stackoverflow上找到了解决方案。 如果刚刚启动了mongodb请关闭。方法参考上面。 输入如下命令启动mongodb。这里 /data/db是mongodb存放数据的目录。homebrew安装一般会自动创建。1mongod --port 27017 --dbpath /data/db 新建一个终端窗口连接mongodb 1mongo --port 27017 输入如下数据库命令创建用户。 12345678use admindb.createUser( &#123; user: &quot;yourname&quot;, pwd: &quot;yourpwd&quot;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;) 关闭数据库并用如下命令重启。 1mongod --auth --port 27017 --dbpath /data/db 连接数据库。 1mongo --port 27017 -u &quot;yourname&quot; -p &quot;yourpwd&quot; --authenticationDatabase &quot;admin&quot; 好了现在就会发现WARNING不见了。 123MongoDB shell version v3.4.6connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.6 在使用时，如果要指定某个用户对某个数据库的操作，可以创建用户指定权限。 比如 Tester用户对test数据对操作为可读可写。 123456789use testdb.createUser( &#123; user: &quot;Tester&quot;, pwd: &quot;123&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;, &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ] &#125;) 连接数据库的命令就变成了 1mongo --port 27017 -u &quot;Tester&quot; -p &quot;123&quot; --authenticationDatabase &quot;test&quot; 当然如果nodejs使用mongoose操作mongodb时，连接的命令也需要填充一些参数 1mongoose.createConnection(&apos;localhost&apos;, &apos;test&apos;, 27017, &#123;user: &apos;Tester&apos;, pass: &apos;123&apos;&#125;); ###2. 启动或关闭数据库时Exception问题12345[initandlisten] exception in initAndListen: 20 Attempted to create a lock file on a read-only directory: /data/db, terminating[initandlisten] shutdown: going to close listening sockets...[initandlisten] shutdown: going to flush diaglog...[initandlisten] now exiting[initandlisten] shutting down with code:100 这个问题是因为 只有root对 /data/db可写，但是你在用自己的账户操作，所以可以用一下命令授权解决问题。 sudo chmod -R go+w /data/db 或者 sudo chown -R $USER /data/db 好了文章就写到这里。再遇见什么坑和问题会后续补充。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://imwyy.github.io/categories/数据库/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"http://imwyy.github.io/tags/踩坑/"},{"name":"安装和配置","slug":"安装和配置","permalink":"http://imwyy.github.io/tags/安装和配置/"}]}]}